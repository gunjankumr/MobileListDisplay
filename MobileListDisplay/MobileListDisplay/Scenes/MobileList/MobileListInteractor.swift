//
//  MobileListInteractor.swift
//  MobileListDisplay
//
//  Created by Sujeet Sinha on 29/9/18.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol MobileListBusinessLogic {
  func getMobileListFromService(request: MobileList.GetMobileList.Request)
  func getSortedMobileList(request: MobileList.GetSortedMobileList.Request)
  func selectedMobile(request: MobileList.SelectedMobile.Request)
}

protocol MobileListDataStore: class {
  var selectedMobile: Mobile { get set }
}

class MobileListInteractor: MobileListBusinessLogic, MobileListDataStore {
  var presenter: MobileListPresentationLogic?
  //var name: String = ""
  
  // MARK: - Business Functions
  var mobiles: [Mobile] = []
  var selectedMobile: Mobile = Mobile()
  let mobileListWorker: MobileListWorker = MobileListWorker()

  func getMobileListFromService(request: MobileList.GetMobileList.Request) {
    mobileListWorker.getMobileList { [weak self] result in
      switch result {
      case .success(let mobiles):
        self?.mobiles = mobiles
        let response = MobileList.GetMobileList.Response(result: .success(mobiles))
        self?.presenter?.presentMobileListFromService(response: response)
      case .failure(.noInternet):
        self?.presenter?.presentMobileListFromService(response: MobileList.GetMobileList.Response(result: .failure(.noInternet)))
      case .failure(.serviceError):
        self?.presenter?.presentMobileListFromService(response: MobileList.GetMobileList.Response(result: .failure(.serviceError)))
      case .failure(.noRecord):
        self?.presenter?.presentMobileListFromService(response: MobileList.GetMobileList.Response(result: .failure(.noRecord)))
      }
    }
  }
  
  func getSortedMobileList(request: MobileList.GetSortedMobileList.Request) {
    
    func getFavouriteItem(sources: [Mobile]) -> [Mobile] {
      let favouriteList = FavouriteListWorker.shared.fetchAllFav()
      return sources.filter { favouriteList.contains($0.id) }
    }
    
    var sortedMobileList: [Mobile] = []
    switch request.sorting {
    case .low:
      sortedMobileList = self.mobiles.sorted { $0.price < $1.price }
    case .high:
      sortedMobileList = self.mobiles.sorted { $0.price > $1.price }
    case .rating:
      sortedMobileList = self.mobiles.sorted { $0.rating > $1.rating }
    }
    
    let response = MobileList.GetSortedMobileList.Response(mobiles: request.selectedTab == .favourite ? getFavouriteItem(sources: sortedMobileList) : sortedMobileList)
    self.presenter?.presentMobileListWithSorting(response: response)
  }
  
  func selectedMobile(request: MobileList.SelectedMobile.Request) {
    guard let selectedMobile = mobiles.first(where: { $0.id == request.id }) else { return }
    self.selectedMobile = selectedMobile
    let response = MobileList.SelectedMobile.Response()
    presenter?.presentSelectedMobile(response: response)
  }
}
